import * as THREE from 'three';
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 10);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
const controls = new OrbitControls(camera, renderer.domElement);

const origin = new THREE.Vector2(-1 , -1);
const height  = 2 , width = 2 ;
const shape = new THREE.Shape();
shape.moveTo(origin.x, origin.y);
shape.lineTo(origin.x + width, origin.y);
shape.lineTo(origin.x + width , origin.y + height);
shape.lineTo(origin.x, origin.y + height);
// shape.lineTo(-1, -1);


class CustomCurve extends THREE.Curve {
    getPoint(t) {
        const direction = 'x';
        // console.log(t);
        switch (direction) {
            case 'x': return new THREE.Vector3(5 * t, 0, 0);
            case '-x': return new THREE.Vector3(-5 * t, 0, 0);
            case 'y': return new THREE.Vector3(0, 5 * t, 0);
            case '-y': return new THREE.Vector3(0, -5 * t, 0);
            case 'z': return new THREE.Vector3(0, 0, 5 * t);
            case '-z': return new THREE.Vector3(0, 0, -5 * t);
            case 'xy': return new THREE.Vector3(5 * t, 5 * t, 0);
            default: return new THREE.Vector3(-5 * t, -5 * t, 0);
        }
    }
}
const customPath = new CustomCurve();

const extrudeSettings = {
    steps: 10,
    bevelEnabled: false,
    extrudePath: customPath
};

// console.log(customPath.getPoints());

const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);


// const meshpositionAttribute = mesh.geometry.attributes.position;
// console.log(meshpositionAttribute);


const vertices = []
const positionAttribute = geometry.attributes.position;
// console.log(positionAttribute);
// console.log(Array.isArray(positionAttribute));
// console.log(typeof positionAttribute);

for (let i = 0; i < positionAttribute.count; i++) {
    const x = positionAttribute.getX(i);
    const y = positionAttribute.getY(i);
    const z = positionAttribute.getZ(i);
    vertices.push([x, y, z]);
}

// console.log(vertices);

// vertices.forEach((v) =>{
//     console.log(v);    
// })

const uniqueVertices = [...new Set(vertices.map((v) => JSON.stringify(v)))].map(
    (v) => JSON.parse(v)
);

// console.log(uniqueVertices);

uniqueVertices.forEach((v) =>{
    const sphere = new THREE.SphereGeometry(0.05);
    const meshMate = new THREE.MeshBasicMaterial({color:0x000ff});
    const spheremesh = new THREE.Mesh(sphere , meshMate);
    spheremesh.position.set(v[0] , v[1] , v[2]);
    scene.add(spheremesh);
})


const maxX = Math.max(...uniqueVertices.map((v) => v[0]));
const lastCrossSection = uniqueVertices.filter((v) => v[0] === maxX);

const previousXValues = uniqueVertices.map((v) => v[0]).filter((x) => x < maxX);

if (previousXValues.length > 0) {
  const secondMaxX = Math.max(...previousXValues);
  var previousCrossSection = uniqueVertices.filter((v) => v[0] === secondMaxX);
} else {
  var previousCrossSection = [];
}

console.log("Last 4 Points:", lastCrossSection);
console.log("Previous 4 Points:", previousCrossSection);

lastCrossSection.forEach((v) => {
  const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
  const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); 
  const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
  sphere.position.set(v[0], v[1], v[2]);
  scene.add(sphere);
});

previousCrossSection.forEach((v) => {
  const sphereGeometry = new THREE.SphereGeometry(0.1, 16, 16);
  const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
  const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
  sphere.position.set(v[0], v[1], v[2]);
  scene.add(sphere);
});



const  distBetweenPointsperpendicular = lastCrossSection[0][0] - previousCrossSection[0][0] ;
const distBetweenPointsBase = height ; 
console.log(distBetweenPointsBase , distBetweenPointsperpendicular);

const angleRadians = Math.atan(distBetweenPointsperpendicular / distBetweenPointsBase);
// const angleDegrees = angleRadians * (180 / Math.PI);


const angleDegrees = 28;
const calRadian = angleDegrees * (Math.PI / 180);
// console.log(`Angle in radians: ${angleRadians}`);
// console.log(`Angle in degrees: ${angleDegrees}`);
// console.log(distBetweenPointsBase * Math.tan(angleRadians));

const distToMove = distBetweenPointsBase * Math.tan(calRadian); 



//  v1 = [5, 1, 1];    v2 = [5, 1, -1];
//  v3 = [5, -1, 1];     v4 = [5, -1, -1];

const v1 = [5, 1, 1];
const v2 = [5 - distToMove, 1, 1];
const v3 = [5, 1, -1];
const v4 = [5 - distToMove, 1, -1];

for (let i = 0; i < positionAttribute.count; i++) {
  const x = positionAttribute.getX(i);
  const y = positionAttribute.getY(i);
  const z = positionAttribute.getZ(i);

  if (x === v1[0] && y === v1[1] && z === v1[2]) {
    positionAttribute.setXYZ(i, v2[0], v2[1], v2[2]);
  }
  if (x === v3[0] && y === v3[1] && z === v3[2]) {
    positionAttribute.setXYZ(i, v4[0], v4[1], v4[2]);
  }
}
positionAttribute.needsUpdate = true;
geometry.computeVertexNormals();
mesh.geometry = geometry;



window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});


function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();
