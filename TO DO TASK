//#region  import abd Helper
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 600);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
const controls = new OrbitControls(camera, renderer.domElement);

const directionalTop = new THREE.DirectionalLight(0xffffff, 1);
directionalTop.position.set(0, 50, 0);
scene.add(directionalTop);

const directionalDown = new THREE.DirectionalLight(0xffffff, 1);
directionalDown.position.set(0, -20, -50);
scene.add(directionalDown);

const directionalRight = new THREE.DirectionalLight(0xffffff, 1);
directionalRight.position.set(50, 0, 50);
scene.add(directionalRight);

const directionalLight4 = new THREE.DirectionalLight(0xffffff, 1);
directionalLight4.position.set(-50, 0, 0);
scene.add(directionalLight4);


function pointsIdentification(x, y, z) {
    const ch = new THREE.SphereGeometry(1)
    const chmat = new THREE.MeshBasicMaterial({ color: 'blue' })
    const chmesh = new THREE.Mesh(ch, chmat);
    chmesh.position.set(x, y, z);
    scene.add(chmesh)
}

//#endregion

//#region Handle (fun 31 - 32 ) (Lift and slide handle)
const turnLeft = true;
let backPlateHeight = 500;
let backPlateWidth = 100;
let handleWidth = 200;
let handleHeight = 50;
let y_key_pos = 0;
const handleBaseExtrude = 10;
const handleExtraHeight = 100;
//#region Hnadle Base
function fun31() {
    const x_Patio_handle = 0, y_Patio_handle = -300, z_Patio_handle = 0;

    const origin = new THREE.Vector2(0, 0);
    const path = new THREE.Shape();
    path.absarc(origin.x + backPlateWidth / 2, origin.y, backPlateWidth / 2, Math.PI, 0, false);
    path.lineTo(origin.x + backPlateWidth, origin.y + backPlateHeight);
    path.absarc(origin.x + backPlateWidth / 2, origin.y + backPlateHeight, backPlateWidth / 2, 0, Math.PI, false);
    path.lineTo();

    const baseExtrude = 0;
    const geo = new THREE.ExtrudeGeometry(path, { depth: baseExtrude, bevelEnabled: false });
    const geoMat = new THREE.MeshPhysicalMaterial({ color: "#e4e6e8", wireframe: false });
    const backPlate = new THREE.Mesh(geo, geoMat);
    backPlate.position.set(x_Patio_handle, y_Patio_handle, z_Patio_handle);
    scene.add(backPlate);

    const contour = path.getPoints(50);
    const frontEdges = new THREE.LineLoop(new THREE.BufferGeometry().setFromPoints(contour), new THREE.LineBasicMaterial({ color: "white" }));
    const backEdges = frontEdges.clone();
    backEdges.position.set(0, 0, baseExtrude);
    backPlate.add(frontEdges);
    backPlate.add(backEdges);

    const radiusTop = backPlateWidth / 2 - 10 , radiusBottom = backPlateWidth / 2, cylinderHeight = 20;
    const geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, cylinderHeight, 32);
    const material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: false });
    const cylinder = new THREE.Mesh(geometry, material);
    cylinder.position.set(backPlateWidth / 2, backPlateHeight / 2, cylinderHeight / 2 + 0.1)
    cylinder.rotateX(Math.PI / 2);
    backPlate.add(cylinder);

}
//#endregion

//#region LS Handle
function fun32() {
    const path = new THREE.Shape();
    path.moveTo(0, 0);
    path.quadraticCurveTo(handleWidth / 2, - handleHeight / 2, handleWidth, 0)
    path.lineTo(handleWidth, handleHeight)
    path.quadraticCurveTo(handleWidth / 2, handleHeight + handleHeight / 2, 0, handleHeight)
    path.lineTo()
    const geo = new THREE.ExtrudeGeometry(path, { depth: handleBaseExtrude, bevelEnabled: false });
    const geoMat = new THREE.MeshPhysicalMaterial({ color: "#e4e6e8", wireframe: false });
    const mesh = new THREE.Mesh(geo, geoMat);
    mesh.position.set(0, 0, 0);
    scene.add(mesh);

    const handleCurve = fun33();
    mesh.add(handleCurve)
}
//#endregion

//#region LS Handle curve
function fun33() {
    const curveHeight = handleExtraHeight / 2;
    const path = new THREE.Shape();
    path.moveTo(0, 0);
    path.quadraticCurveTo(curveHeight / 4 - 5, curveHeight / 1 - 5, -curveHeight / 4, curveHeight);
    path.lineTo(-curveHeight / 4, curveHeight + handleBaseExtrude);
    path.quadraticCurveTo(handleBaseExtrude, curveHeight + handleBaseExtrude, handleBaseExtrude * 2 + 5 , curveHeight / 1.5);
    path.lineTo(handleBaseExtrude * 2.8, 0);

    const geo = new THREE.ExtrudeGeometry(path, { depth: handleHeight, bevelEnabled: false });
    const geoMat = new THREE.MeshPhysicalMaterial({ color: "#e4e6e8", wireframe: false, wireframe: false });
    const mesh = new THREE.Mesh(geo, geoMat);
    mesh.position.set(handleWidth + 10, handleHeight, -handleExtraHeight / 2);
    mesh.rotateX(Math.PI / 2)
    // scene.add(mesh);

    return mesh;
}
//#endregion

//#endregion

fun32();

//#region Render
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();

//#endregion
